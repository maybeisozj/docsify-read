# TCP三次握手与四次挥手

## TCP报文结构

![图片加载中](https://i.loli.net/2020/09/18/RoKzgNEdX4L67nV.gif)

首先了解一下TCP的报文格式吧，上图就是tcp的报文结构，其中：

1. **端口号**：用来标识同一台计算机的不同的应用进程。

   1）源端口：源端口和IP地址的作用是标识报文的返回地址。

   2）目的端口：端口指明接收方计算机上的应用程序接口。

   TCP报头中的**源端口号和目的端口号同IP数据报中的源IP与目的IP**唯一确定一条TCP连接。

2. **序号**：该报文首字节的字节流编号。

3. **确认序号**：期望从对方收到的下一字节的序号。

4. **数据偏移(首部长度)**:因为存在选项字段，首部长度是可变的。一般选项为空，长度为20字节，最大60（15*32/8）字节。

5. **保留**：未用。

6. **窗口**：用于流量控制，指示接收方愿意接受的字节的数量。

7. **检验和**：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。

8. **紧急指针**：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。

9. **选项和填充**：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。

10. **标志字段**：

    **ACK**：用于指示确认字段中的值是有效的，即该报文段包含一个对已被成功接收报文段的确认。

    **URG**：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。

    **PSH**：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。

    **RST**：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。

    **SYN**：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。

    **FIN**：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。

11. **数据部分**： TCP 报文段中的数据部分是可选的。在一个连接建立（第三次握手可以携带数据）和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。

## 三次握手

### 流程

![image-20200918201907844](https://i.loli.net/2020/09/18/9wtGajnoLRs2AQy.png)

约定，将发起连接的应用程序称为客户端，接收连接的称为服务器端。

第一次握手：客户端发起连接，将**SYN**置为1，随机产生一个序号j使得**seq=j**，将该数据包发送给服务端并且进入SYN_SENT状态。

第二次握手：服务端收到数据包后根据**SYN=1**得知客户端想要建立连接，服务端将SYN，ACK置为1，ack=j+1，seq=k(随机产生)，将该报文发送给客户端并且进入SYN_RCVD状态。

第三次握手：客户端接收到报文之后，检查ack是否为j+1，ACK是否1，将ACK置为1，ack=k+1，此时可以在数据部分发送数据了。客户端进入了ESTABLISHED状态。服务端接收到后检查是否ack为k+1，正确的话连接建立成功，进入ESTABLISHED状态。

在以上整个流程中，SYN只有在前两次握手中才是1，之后发送数据的报文中全是0（包含四次挥手）。

### 为什么要三次握手

**1. 三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

**2. TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN（初始 seq 序列号）**

比如：如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

## 四次挥手

### 流程

![image-20200918203453131](https://i.loli.net/2020/09/18/nwomjzfxDLVU5KS.png)

第一次挥手：客户端将FIN置为1，将断开连接请求发送给服务端，进入FIN_WAIT_1状态。

第二次挥手：服务端接收到数据包之后将ACK置为1表示接收到了断开请求，将数据包发送给客户端，进入CLOSE_WAIT状态。客户端接收到应答之后进入FIN_WAIT_2状态。**此时服务端仍然可以向客户端发送数据包。**

第三次挥手：服务端确认数据包发送完成之后发送FIN=1的数据包请求断开连接，进入LAST_ACK状态。

第四次挥手：客户端接收到请求之后向服务端发送ACK=1数据包并进入TIME_WAIT状态，服务端接收到数据包之后进入CLOSED状态，关闭了连接。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，客户端也可以关闭连接了。TIME_WAIT状态是为了保证假如数据包丢失可以重传。

最终完成了四次握手。

### 为什么要四次挥手

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

### 为什么还要等待2MSL时间

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。